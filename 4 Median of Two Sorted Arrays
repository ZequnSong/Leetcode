/*
There are two sorted arrays nums1 and nums2 of size m and n respectively.
Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
You may assume nums1 and nums2 cannot be both empty.

Example :

nums1 = [1]
nums2 = [20，21]

The median is 20

题目求中位数确定了a和b最终分成的左右两份的个数是确定的，都是所有元素的个数的一半
将问题转化为准确切割a

*/
class Solution {
    public double findMedianSortedArrays(int[] a, int[] b) {
    //确保a是短的部分，处理相对更短的数组，耗时更短
        if(a.length > b.length){
            return findMedianSortedArrays(b, a);
        }
        int len = a.length + b.length;
        int cut1 = 0;                //代表a数组切一刀后左边的元素个数
        int cut2 = 0;                //代表b数组切一刀后左边的元素个数
        int cutL = 0;                //切割区间下限，相当于二分法的Left边
        int cutR = a.length;         //切割区间上限，相当于二分法的right边
        while(cut1 <= a.length){
            cut1 = (cutR - cutL)/2 + cutL;
            cut2 = len/2 - cut1;
            double L1 = (cut1 == 0) ? Integer.MIN_VALUE : a[cut1 - 1];   //cut1=0的情形见上方的Example 
            double R1 = (cut1 == a.length) ? Integer.MAX_VALUE : a[cut1];
            double L2 = (cut2 == 0) ? Integer.MIN_VALUE : b[cut2 - 1];
            double R2 = (cut2 == b.length) ? Integer.MAX_VALUE : b[cut2];
            if(L1 > R2){
                cutR = cut1 - 1;
            }else if(L2 > R1){
                cutL = cut1 + 1;
            }else {
                if(len % 2 ==0){            //偶数时的情况
                    L1 = (L1>L2) ? L1 : L2;
                    R1 = (R1<R2) ? R1 : R2;
                    return (L1 + R1)/2;
                }else{                      //奇数时的情况
                    R1 = (R1<R2) ? R1 : R2;
                    return R1;
                }
            }                
        }
        return -1;
    }
}
